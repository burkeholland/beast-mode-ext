<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="%%CSP%%" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beast Mode Settings</title>
  <style>
    /* Base */
    :root {
      color-scheme: light dark;
    }

    body {
      font-family: var(--vscode-font-family);
      color: var(--vscode-foreground);
      padding: 8px 10px 24px;
      font-size: 12.5px;
    }

    h1 {
      font-size: 14px;
      margin: 4px 0 12px;
      letter-spacing: .2px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    h2 {
      font-size: 11px;
      font-weight: 700;
      margin: 16px 0 6px;
      text-transform: uppercase;
      opacity: .75;
      letter-spacing: .6px;
    }

    .section {
      margin-bottom: 24px;
    }

    .section+.section {
      margin-top: 12px;
      padding-top: 14px;
      border-top: 1px solid var(--vscode-tree-indentGuidesStroke, var(--vscode-widget-border, transparent));
    }

    /* List layout (no boxes) */
    .settings-list {
      position: relative;
      border: none;
      border-radius: 0;
      background: transparent;
      overflow: visible;
      /* enable container queries so we can respond to the panel's width */
      container-type: inline-size;
    }

    /* Default layout: two-column with controls on the right */
    .setting {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      column-gap: 14px;
      row-gap: 6px;
      padding: 12px 2px;
    }

    .setting:hover {
      background: var(--vscode-list-hoverBackground);
    }

    .setting-main {
      min-width: 0;
    }

    .setting-main label {
      font-weight: 600;
      display: inline-block;
      margin-bottom: 2px;
    }

    .setting-main .heading {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .info {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  font-size: 12px;
  line-height: 18px;
  color: var(--vscode-foreground);
  background: color-mix(in srgb, var(--vscode-input-background) 85%, transparent);
  border: 1px solid var(--vscode-widget-border, transparent);
  opacity: .9;
  cursor: default;
    }

    .info:hover {
      opacity: 1;
    }

    /* Recommendation indicator */
    .recommendation-indicator {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--vscode-inputValidation-warningForeground, #d19a66);
      margin-left: 6px;
      cursor: pointer;
      position: relative;
      flex-shrink: 0;
    }

    .recommendation-indicator:hover {
      transform: scale(1.2);
      transition: transform 0.1s ease;
    }

    .recommendation-indicator:focus {
      outline: 1px solid var(--vscode-focusBorder);
      outline-offset: 2px;
    }

    .desc {
      font-size: 11.5px;
      opacity: .78;
      line-height: 1.35;
    }

    .setting-right {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      min-width: 120px;
    }

    .setting-main .control {
      display: block;
      margin-top: 8px;
    }

    /* Inputs */
    .control,
    .select-control {
      box-sizing: border-box;
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border, var(--vscode-widget-border));
      border-radius: 6px;
      height: 24px;
      outline: none;
    }

    input[type=text].control,
    input[type=number].control {
      width: 180px;
      max-width: 40vw;
      padding: 2px 8px;
    }

    /* Make numeric stepper proportionate */
    input[type=number].control {
      width: 120px;
      min-width: 90px;
    }

    select.select-control {
      padding: 2px 6px;
      height: 24px;
      border-radius: 4px;
    }

    input[type=number]:focus,
    input[type=text]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--vscode-focusBorder);
      box-shadow: 0 0 0 1px var(--vscode-focusBorder);
    }

    textarea {
      width: 100%;
      max-width: 100%;
      min-height: 84px;
      resize: vertical;
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border, var(--vscode-widget-border));
      border-radius: 6px;
      padding: 8px 10px;
      outline: none;
      font-family: var(--vscode-editor-font-family, monospace);
      font-size: 12px;
      line-height: 1.45;
    }

    textarea.invalid {
      border-color: var(--vscode-inputValidation-errorBorder);
      box-shadow: 0 0 0 1px var(--vscode-inputValidation-errorBorder);
    }

    input.number-invalid {
      border-color: var(--vscode-inputValidation-errorBorder);
      box-shadow: 0 0 0 1px var(--vscode-inputValidation-errorBorder);
    }

    /* Toggle */
    .switch {
      position: relative;
      display: inline-block;
      width: 38px;
      height: 22px;
      flex-shrink: 0;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      inset: 0;
      cursor: pointer;
      background: var(--vscode-input-background);
      transition: .18s ease;
      border: 1px solid var(--vscode-input-border, var(--vscode-widget-border));
      border-radius: 22px;
      box-sizing: border-box;
    }

    .slider:before {
      content: "";
      position: absolute;
      height: 16px;
      width: 16px;
      left: 2px;
      top: 2px;
      background: var(--vscode-editor-background, #fff);
      transition: .18s ease;
      border-radius: 50%;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .25);
    }

    .switch input:focus+.slider {
      outline: 1px solid var(--vscode-focusBorder);
    }

    .switch input:checked+.slider {
      background: var(--vscode-button-background, var(--vscode-statusBarItem-prominentBackground));
      border-color: var(--vscode-button-border, var(--vscode-button-background));
    }

    .switch input:checked+.slider:before {
      transform: translateX(16px);
    }

    .switch input:active+.slider:before {
      width: 17px;
    }

    /* Buttons */
    button.inline {
      background: transparent;
      color: var(--vscode-textLink-foreground);
      border: none;
      border-radius: 4px;
      height: 24px;
      padding: 0 2px;
      cursor: pointer;
      text-decoration: none;
    }

    button.inline:hover {
      text-decoration: underline;
    }

    /* Overlay */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      background: rgba(0, 0, 0, .25);
      backdrop-filter: blur(1px);
    }

    .overlay-card {
      background: var(--vscode-editor-background);
      color: var(--vscode-foreground);
      border: 1px solid var(--vscode-widget-border);
      border-radius: 8px;
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .25);
      max-width: 90%;
    }

    .overlay-card .msg {
      font-size: 12px;
      opacity: .9;
    }

    .overlay-card button {
      height: 26px;
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: 1px solid var(--vscode-button-border, transparent);
      border-radius: 6px;
      padding: 0 10px;
    }

    /* Themed tooltip */
    .tooltip {
      position: fixed;
      z-index: 9999;
      background: var(--vscode-editorHoverWidget-background, var(--vscode-editorWidget-background));
      color: var(--vscode-editorHoverWidget-foreground, var(--vscode-foreground));
      border: 1px solid var(--vscode-editorHoverWidget-border, var(--vscode-widget-border));
      box-shadow: 0 6px 20px rgba(0, 0, 0, .28);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12.5px;
      line-height: 1.4;
      max-width: 360px;
      min-width: 140px;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-2px);
      transition: opacity .12s ease, transform .12s ease;
      white-space: pre-wrap;
    }

    .tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .tooltip::after {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: inherit;
      border-left: inherit;
      border-top: inherit;
  left: var(--_arrow-left, 16px);
  top: var(--_arrow-top, -4px);
  transform: rotate(var(--_arrow-rotate, 45deg));
    }

    /* Compact remote indicator */
    .remote-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 6px;
      background: transparent;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 12px;
      border: 1px solid transparent;
      transition: background .12s ease, border-color .12s ease, transform .06s ease;
    }

    .remote-indicator:focus,
    .remote-indicator:hover {
      outline: none;
      border-color: color-mix(in srgb, var(--vscode-button-background) 16%, transparent);
      background: color-mix(in srgb, var(--vscode-list-hoverBackground, rgba(0,0,0,0.04)) 50%, transparent);
    }

    .remote-indicator .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--vscode-inputValidation-infoBorder, #0ea5e9);
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--vscode-list-hoverBackground, rgba(0,0,0,0.04)) 30%, transparent);
      transition: transform .18s ease, opacity .18s ease;
    }

    .remote-indicator.loading { opacity: .9; }

    .remote-indicator .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid transparent;
      border-top-color: var(--vscode-button-foreground);
      border-right-color: var(--vscode-button-foreground);
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }

    @keyframes pulse { 0% { transform: scale(1); opacity: 1 } 50% { transform: scale(1.35); opacity: .7 } 100% { transform: scale(1); opacity: 1 } }

    .settings-footer {
      margin-top: 14px;
      font-size: 12px;
      color: var(--vscode-foreground);
      opacity: .8;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .settings-footer .last-checked { font-size: 12px; opacity: .85; }

  </style>
</head>

<body>
  <h1>Beast Mode Configuration <span id="remoteIndicatorRoot"></span></h1>
  <div id="remoteBannerContainer" aria-live="polite" style="display:none"></div>
  <div id="settingsContainer" role="region" aria-label="Settings"></div>

  <div class="settings-footer" id="settingsFooter" role="contentinfo">
    <div></div>
    <div class="last-checked" id="footerLastChecked">Last checked: Never</div>
  </div>

  <script type="application/json" id="initialState" nonce="%%NONCE%%">%%STATE_JSON%%</script>
  <script nonce="%%NONCE%%">
    ; (() => {
      // VS Code webview API
      const vscode = acquireVsCodeApi();

      /** Utilities **/
      /** @template T */
      const debounce = (fn, wait = 300) => {
        let t;
        return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
      };

      const $ = (sel, root = document) => /** @type {HTMLElement|null} */(root.querySelector(sel));

      /** Create element helper */
      const el = (tag, attrs = {}, children = []) => {
        const node = document.createElement(tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (k === 'className') node.className = String(v);
          else if (k === 'dataset' && v && typeof v === 'object') Object.assign(node.dataset, v);
          else if (k in node) node[k] = v;
          else node.setAttribute(k, String(v));
        }
        for (const child of Array.isArray(children) ? children : [children]) {
          if (child == null) continue;
          node.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
        }
        return node;
      };

      const safeParseJSON = (text) => {
        try { return text ? JSON.parse(text) : null; } catch { return null; }
      };

      /** Typedefs (for editors) */
  /**
   * @typedef {{ key:string,title?:string,description:string,type:'boolean'|'number'|'string'|'json', group?:string, min?:number, step?:number, options?:{value:string,label?:string}[], info?:string, missingExtensions?:string[] }} SettingDef
   * @typedef {{ settings: Record<string, any>, definitions: SettingDef[], groups: string[] }} SettingsState
   */

      // State
      const stateEl = /** @type {HTMLScriptElement|null} */ (document.getElementById('initialState'));
      /** @type {SettingsState} */
  let currentState = safeParseJSON(stateEl?.textContent || '') || { settings: {}, definitions: [], groups: [] };

      /** DOM roots */
      const settingsRoot = /** @type {HTMLElement} */($('#settingsContainer'));
      const remoteBannerContainer = /** @type {HTMLElement} */($('#remoteBannerContainer'));

      /** Tooltip management */
      let tooltipEl = /** @type {HTMLDivElement|null} */(null);
      let hideTooltipTimer = /** @type {number|undefined} */(undefined);

      const ensureTooltip = () => {
        if (!tooltipEl) {
          tooltipEl = document.createElement('div');
          tooltipEl.className = 'tooltip';
          tooltipEl.setAttribute('role', 'tooltip');
          document.body.appendChild(tooltipEl);
        }
        return tooltipEl;
      };

      /**
       * @param {HTMLElement} target
       * @param {string} text
       */
      const showTooltip = (target, text) => {
        const tip = ensureTooltip();
        window.clearTimeout(hideTooltipTimer);
        tip.textContent = text;
        tip.classList.add('visible');

        // Position near target (prefer above)
        const rect = target.getBoundingClientRect();
        // First set offscreen to measure
        tip.style.left = '-9999px';
        tip.style.top = '-9999px';
        tip.style.maxWidth = '360px';

        // Force layout
        const { offsetWidth: w, offsetHeight: h } = tip;
        const margin = 8;
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;

        let top = rect.top - h - 10; // above with arrow
        let left = rect.left + rect.width / 2 - w / 2;
        let arrowAt = 'bottom';

        if (top < margin) {
          // Place below
          top = rect.bottom + 10;
          arrowAt = 'top';
        }

        // Clamp horizontally
        left = Math.max(margin, Math.min(left, viewportW - w - margin));

        tip.style.top = `${Math.round(top)}px`;
        tip.style.left = `${Math.round(left)}px`;

        // Arrow positioning
        const arrowSize = 8;
        const arrowLeft = rect.left + rect.width / 2 - arrowSize / 2 - left;
        tip.style.setProperty('--_arrow-left', `${Math.max(12, Math.min(w - 12 - arrowSize, arrowLeft))}px`);
        tip.style.setProperty('--_arrow-size', `${arrowSize}px`);
        if (arrowAt === 'bottom') {
          tip.style.setProperty('--_arrow-top', `${h - arrowSize / 2 - 1}px`);
          tip.style.setProperty('--_arrow-rotate', '45deg');
        } else {
          tip.style.setProperty('--_arrow-top', `${-arrowSize / 2 + 1}px`);
          tip.style.setProperty('--_arrow-rotate', '225deg');
        }
        tip.style.setProperty('--_arrow-border', getComputedStyle(tip).borderColor);

        // Apply arrow
        tip.style.setProperty('clip-path', ''); // no-op to ensure style recalculation
        tip.style.position = 'fixed';
        tip.style.pointerEvents = 'none';
        tip.style.setProperty('--_arrow-bg', getComputedStyle(tip).backgroundColor);
        tip.style.setProperty('--_arrow-shadow', 'rgba(0,0,0,.18)');
        tip.style.setProperty('--_arrow-left', tip.style.getPropertyValue('--_arrow-left'));
        tip.style.setProperty('--_arrow-top', tip.style.getPropertyValue('--_arrow-top'));
        tip.style.setProperty('--_arrow-size', tip.style.getPropertyValue('--_arrow-size'));

        // Manually position ::after arrow via inline styles (CSS uses variables)
        tip.style.setProperty('--_arrow-display', 'block');
        tip.style.setProperty('--_arrow-rotate', tip.style.getPropertyValue('--_arrow-rotate'));
      };

      const hideTooltip = (delay = 120) => {
        const tip = ensureTooltip();
        window.clearTimeout(hideTooltipTimer);
        hideTooltipTimer = window.setTimeout(() => {
          tip.classList.remove('visible');
        }, delay);
      };

      /** Compute common missing extension IDs across defs in a group */
      const computeCommonMissing = (defs) => {
        if (!defs.length) return [];
        const base = new Set(defs[0].missingExtensions || []);
        for (let i = 1; i < defs.length; i++) {
          const next = new Set(defs[i].missingExtensions || []);
          for (const id of Array.from(base)) {
            if (!next.has(id)) base.delete(id);
          }
        }
        return Array.from(base);
      };

      /** Build a stable, valid id from a setting key */
      const idFromKey = (key) => `setting-${key.replace(/[^a-z0-9\-_.]/gi, '-')}`;

      /** Post helpers */
      const postUpdate = (key, value) => vscode.postMessage({ type: 'updateSetting', key, value });
      const postInstall = (ids) => vscode.postMessage({ type: 'installExtensions', ids });
      const postCheckRemote = () => vscode.postMessage({ type: 'checkRemoteNow' });

      /** Controls factory **/
      const makeRecommendationIndicator = (def) => {
        if (!def.hasRecommendation || def.matchesRecommendation) {
          return null;
        }

        const indicator = el('span', {
          className: 'recommendation-indicator',
          tabindex: 0,
          'aria-label': `Recommended value: ${formatRecommendedValue(def.recommended, def.type)}`,
          'data-recommended': def.recommended,
          role: 'img'
        });

        const tooltipText = `Recommended: ${formatRecommendedValue(def.recommended, def.type)}`;
        
        // Mouse and keyboard interactions
        indicator.addEventListener('mouseenter', () => showTooltip(indicator, tooltipText));
        indicator.addEventListener('mouseleave', () => hideTooltip());
        indicator.addEventListener('focus', () => showTooltip(indicator, tooltipText));
        indicator.addEventListener('blur', () => hideTooltip(0));
        indicator.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') hideTooltip(0);
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            showTooltip(indicator, tooltipText);
          }
        });

        return indicator;
      };

      const formatRecommendedValue = (value, type) => {
        if (value === null || value === undefined) return 'null';
        if (type === 'boolean') return value ? 'true' : 'false';
        if (type === 'json') {
          try {
            return JSON.stringify(value);
          } catch {
            return String(value);
          }
        }
        return String(value);
      };

      const makeSelect = (def, value, disabled) => {
        const select = /** @type {HTMLSelectElement} */(el('select', { className: 'select-control', disabled }));
        for (const opt of def.options || []) {
          const o = el('option', { value: opt.value }, opt.label || opt.value);
          if (String(value) === opt.value) o.setAttribute('selected', 'true');
          select.appendChild(o);
        }
        select.addEventListener('change', () => postUpdate(def.key, select.value));
        return select;
      };

      const makeToggle = (def, value, disabled) => {
        const wrap = el('label', { className: 'switch control', role: 'switch', 'aria-checked': !!value });
        const input = /** @type {HTMLInputElement} */(el('input', { type: 'checkbox', checked: !!value, disabled, 'aria-label': def.title || def.key }));
        const slider = el('span', { className: 'slider' });
        input.addEventListener('change', () => { wrap.setAttribute('aria-checked', String(input.checked)); postUpdate(def.key, input.checked); });
        wrap.appendChild(input); wrap.appendChild(slider);
        return wrap;
      };

      const makeNumber = (def, value, disabled) => {
        const input = /** @type {HTMLInputElement} */(el('input', { className: 'control', type: 'number', value: value ?? '', min: def.min, step: def.step, inputMode: 'numeric', disabled, id: idFromKey(def.key) }));
        const onInput = () => {
          const num = Number(input.value);
          if (!Number.isInteger(num) || (def.min !== undefined && num < def.min)) {
            input.classList.add('number-invalid');
            return;
          }
          input.classList.remove('number-invalid');
          postUpdate(def.key, num);
        };
        input.addEventListener('input', debounce(onInput, 300));
        return input;
      };

      const makeText = (def, value, disabled) => {
        const input = /** @type {HTMLInputElement} */(el('input', { className: 'control', type: 'text', value: value ?? '', disabled, id: idFromKey(def.key) }));
        input.addEventListener('input', debounce(() => postUpdate(def.key, input.value), 400));
        return input;
      };

      const makeJSON = (def, value, disabled) => {
        const area = /** @type {HTMLTextAreaElement} */(el('textarea', { className: 'control', disabled, id: idFromKey(def.key) }));
        try { area.value = JSON.stringify(value ?? null, null, 2); } catch { area.value = 'null'; }
        const onInput = () => {
          try { const parsed = JSON.parse(area.value); area.classList.remove('invalid'); postUpdate(def.key, parsed); }
          catch { area.classList.add('invalid'); }
        };
        area.addEventListener('input', debounce(onInput, 500));
        return area;
      };

      /** Rendering **/
      const render = () => {
        // Settings groups
        settingsRoot.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (const group of currentState.groups) {
          const section = el('div', { className: 'section', role: 'region', 'aria-label': group });
          section.appendChild(el('h2', {}, group));
          const list = el('div', { className: 'settings-list' });
          const defs = currentState.definitions.filter(d => d.group === group);
          for (const def of defs) list.appendChild(renderSetting(def));
          section.appendChild(list);

          const commonMissing = computeCommonMissing(defs);
          if (commonMissing.length) {
            const overlay = el('div', { className: 'overlay' });
            const card = el('div', { className: 'overlay-card' });
            const msg = el('div', { className: 'msg' }, `Requires extension${commonMissing.length > 1 ? 's' : ''}: ${commonMissing.join(', ')}`);
            const btn = el('button', { className: 'inline', type: 'button' }, 'Install');
            btn.addEventListener('click', () => postInstall(commonMissing));
            card.appendChild(msg); card.appendChild(btn); overlay.appendChild(card); list.appendChild(overlay);
          }

          frag.appendChild(section);
        }
        settingsRoot.appendChild(frag);
        renderRemoteBanner();
      };

      /** Render remote update indicator (compact) */
      const renderRemoteBanner = () => {
        // Compact indicator in header and timestamp in footer
        const indicatorRoot = document.getElementById('remoteIndicatorRoot');
        const footerTs = document.getElementById('footerLastChecked');
        if (!indicatorRoot || !footerTs) return;

        const lastCheckedISO = currentState.remoteLastChecked || null;
        const formatChecked = (iso) => {
          if (!iso) return 'Never';
          try { const d = new Date(iso); return d.toLocaleString(); } catch { return iso; }
        };

        // Indicator: dot color reflects pending state
        indicatorRoot.innerHTML = '';
        const ind = el('button', { className: 'remote-indicator', type: 'button', title: currentState.remotePending ? 'Remote config update available' : 'Remote config up to date', 'aria-pressed': 'false' });
        const dot = el('span', { className: 'dot' });
        ind.appendChild(dot);

        // If pending, show a compact 'Update' label; otherwise show subtle 'Status' text
        if (currentState.remotePending) {
          const note = el('span', { className: 'label' }, 'Update');
          ind.appendChild(note);
        } else {
          const note = el('span', { className: 'label' }, 'Remote');
          ind.appendChild(note);
        }

        // Click behaviour: trigger a manual check and show spinner feedback
        ind.addEventListener('click', () => {
          // show immediate feedback
          ind.classList.add('loading');
          ind.setAttribute('aria-pressed', 'true');
          const spinner = el('span', { className: 'spinner' });
          // prefer to show spinner instead of label
          const labelEl = ind.querySelector('.label');
          if (labelEl) labelEl.style.display = 'none';
          ind.appendChild(spinner);
          // Post message to extension to check now
          postCheckRemote();
          // Clear visual loading after a few seconds in case extension doesn't update state
          setTimeout(() => {
            try { ind.classList.remove('loading'); ind.setAttribute('aria-pressed', 'false'); if (spinner.parentNode) spinner.parentNode.removeChild(spinner); if (labelEl) labelEl.style.display = ''; } catch {};
          }, 4000);
        });

        indicatorRoot.appendChild(ind);

        footerTs.textContent = `Last checked: ${formatChecked(lastCheckedISO)}`;
      };

      const remoteCheckWithFeedback = (btnEl) => {
        if (!btnEl) return;
        btnEl.classList.add('loading');
        const spinner = el('span', { className: 'spinner' });
        btnEl.prepend(spinner);
        // Send request to extension
        postCheckRemote();
        // After a short timeout, clear loading state in case extension response is delayed; extension will re-render and replace HTML when ready.
        setTimeout(() => {
          try {
            btnEl.classList.remove('loading');
            const fc = btnEl.firstChild;
            if (fc && fc.nodeType === 1) {
              const fe = /** @type {Element} */ (fc);
              if (fe.classList && typeof fe.classList.contains === 'function' && fe.classList.contains('spinner')) {
                btnEl.removeChild(fc);
              }
            }
          } catch {}
        }, 3000);
      };

      const renderSetting = (def) => {
        const value = currentState.settings[def.key];
        const row = el('div', { className: 'setting' });
        const main = el('div', { className: 'setting-main' });

        const labelId = idFromKey(def.key) + '-label';
        const label = el('label', { id: labelId, htmlFor: idFromKey(def.key) }, def.title || def.key.split('.').slice(-1)[0]);
        const heading = el('div', { className: 'heading' }, [label]);
        
        // Add info icon if available
        if (def.info) {
          const infoEl = el('span', { className: 'info', tabindex: 0, 'aria-label': 'More info', 'data-info': def.info }, 'i');
          // Mouse and keyboard interactions
          infoEl.addEventListener('mouseenter', () => showTooltip(infoEl, def.info));
          infoEl.addEventListener('mouseleave', () => hideTooltip());
          infoEl.addEventListener('focus', () => showTooltip(infoEl, def.info));
          infoEl.addEventListener('blur', () => hideTooltip(0));
          infoEl.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') hideTooltip(0);
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              showTooltip(infoEl, def.info);
            }
          });
          heading.appendChild(infoEl);
        }

        // Add recommendation indicator if applicable
        const recommendationIndicator = makeRecommendationIndicator(def);
        if (recommendationIndicator) {
          heading.appendChild(recommendationIndicator);
        }
        main.appendChild(heading);
        main.appendChild(el('div', { className: 'desc' }, def.description));

        const missing = Array.isArray(def.missingExtensions) ? def.missingExtensions : [];
        if (missing.length) {
          const warn = el('div', { className: 'desc', style: 'color: var(--vscode-inputValidation-warningForeground, #d19a66);' }, `Requires extension${missing.length > 1 ? 's' : ''}: ${missing.join(', ')}`);
          main.appendChild(warn);
        }

        row.appendChild(main);
        const right = el('div', { className: 'setting-right' });
        const disabled = missing.length > 0;

        if (Array.isArray(def.options) && def.options.length) {
          right.appendChild(makeSelect(def, value, disabled));
        } else if (def.type === 'boolean') {
          right.appendChild(makeToggle(def, value, disabled));
        } else if (def.type === 'number') {
          right.appendChild(makeNumber(def, value, disabled));
        } else if (def.type === 'json') {
          // JSON editor spans full width under description
          main.appendChild(makeJSON(def, value, disabled));
        } else {
          right.appendChild(makeText(def, value, disabled));
        }

        if (missing.length) {
          const btn = el('button', { className: 'inline', type: 'button' }, 'Install');
          btn.addEventListener('click', () => postInstall(missing));
          right.appendChild(btn);
        }

        row.appendChild(right);
        return row;
      };

      // Initial render
      render();

      // Listen for messages from extension that will re-render the whole webview; remove any lingering spinners on message receive
      window.addEventListener('message', (e) => {
        try {
          const data = e.data;
          if (data && data.type === 'stateUpdate') {
            // not used currently; webview HTML is replaced on state change
          }
        } catch {}
        // Clean up any loading classes/spinners in case DOM was not fully replaced
        document.querySelectorAll('.refresh-btn.loading').forEach(b => {
          b.classList.remove('loading');
          const fc = b.firstChild;
          if (fc && fc.nodeType === 1) {
            const fe = fc;
            if (fe.classList && typeof fe.classList.contains === 'function' && fe.classList.contains('spinner')) {
              b.removeChild(fc);
            }
          }
        });
      });

    // Global listeners to prevent lingering tooltips
    window.addEventListener('scroll', () => hideTooltip(0), true);
    window.addEventListener('resize', () => hideTooltip(0));
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideTooltip(0); });
    })();
  </script>
</body>

</html>